---
title: "04. Version Retention & Pruning"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Version Retention & Pruning}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, message=FALSE}
# Use development build when interactive *and* explicitly enabled via env var.
dev_mode <- (Sys.getenv("DEV_VIGNETTES", "false") == "true")

if (dev_mode && requireNamespace("pkgload", quietly = TRUE)) {
  pkgload::load_all(
    export_all = FALSE,
    helpers = FALSE,
    attach_testthat = FALSE
  )
} else {
  # fall back to the installed package (the path CRAN, CI, and pkgdown take)
  library(stamp)
}
```

This vignette shows how to **prune old versions** from the versions store and keep the catalog tidy—either **automatically after each save** or with an **ad-hoc pruning pass**.

Key pieces:

* Global option: `st_opts(retain_versions = policy)`
* On-demand: `st_prune_versions(path = NULL, policy = ..., dry_run = FALSE)`
* Latest version is **always protected**.

Retention **policy** can be:

* `Inf` (default): keep everything.
* An integer `n`: keep **n latest** versions.
* A list like `list(n = 5, days = 14)`: keep the **union** of “5 latest” and “last 14 days”.

> Note: This vignette assumes your package defines `retain_versions = Inf` as a default in `st_opts()` initialization, and that `st_save()` calls an internal `.st_apply_retention()` which reads that option. If you prefer only manual pruning, skip the automatic hook and use `st_prune_versions()` explicitly.

## Setup a temporary project

```{r}
root <- tempdir()
st_init(root)
```

We’ll make three artifacts and a few versions for each.

```{r}
pA <- fs::path(root, "A.qs")
pB <- fs::path(root, "B.qs")
pC <- fs::path(root, "C.qs")

xA1 <- data.frame(a = 1:3)
xA2 <- data.frame(a = 2:4)
xA3 <- data.frame(a = 3:5)

xB1 <- data.frame(b = letters[1:3])
xB2 <- data.frame(b = letters[2:4])

xC1 <- data.frame(c = 10:12)

# Keep retention OFF initially so we can create multiple versions
st_opts(retain_versions = Inf)

st_save(xA1, pA, code = function(z) z)
st_save(xA2, pA, code = function(z) z)
st_save(xA3, pA, code = function(z) z)

st_save(xB1, pB, code = function(z) z)
st_save(xB2, pB, code = function(z) z)

st_save(xC1, pC, code = function(z) z)

# How many versions recorded?
nrow(st_versions(pA))
nrow(st_versions(pB))
nrow(st_versions(pC))
```

You can inspect the versions directory (may be large, so we only list the top-level):

```{r}
vroot <- stamp:::.st_versions_root()
fs::dir_tree(vroot, recurse = FALSE, all = TRUE)
```

And the catalog entries:

```{r}
st_versions(pA)
st_versions(pB)
st_versions(pC)
```

## Ad-hoc pruning (no automatic retention)

### Keep **n latest** (e.g., 2) for a single artifact

```{r}
# Preview only (no deletion):
st_prune_versions(path = pA, policy = 2, dry_run = TRUE)

# Apply:
repA <- st_prune_versions(path = pA, policy = 2, dry_run = FALSE)
repA
nrow(st_versions(pA)) # should be <= 2 (latest always kept)
```

### Keep by **recency window** (e.g., last 14 days) for the whole catalog

```{r}
# Preview:
st_prune_versions(policy = list(days = 14), dry_run = TRUE)

# Apply:
repAll <- st_prune_versions(policy = list(days = 14))
head(repAll)
```

### Combine **n + days** (union)

```{r}
# Keep last 2 versions OR any version within 7 days
st_prune_versions(policy = list(n = 2, days = 7))
```

After pruning, verify the catalog:

```{r}
st_versions(pA)
st_versions(pB)
st_versions(pC)
```

Latest version remains present by design.

## Automatic pruning after each save

If your package calls `.st_apply_retention()` at the end of `st_save()`, you can set a global policy and forget about it:

```{r}
# Keep only the latest 2 versions per artifact going forward
st_opts(retain_versions = 2)

# New save will write a new version and immediately prune older ones
xA4 <- data.frame(a = 4:6)
st_save(xA4, pA, code = function(z) z)

nrow(st_versions(pA)) # should be <= 2
```

You can disable auto-pruning by restoring:

```{r}
st_opts(retain_versions = Inf) # keep all (no-op on save)
```


## Primary-key metadata & load-time checks

Milestone 4 adds **primary-key (PK) metadata** so tables carry their identity and consumers can reason about joins/subsets without out-of-band documentation.

### Recording PK at save time

```{r}
pop <- data.frame(
  country = c("PER", "PER", "COL"),
  year = c(2023, 2024, 2023),
  reporting_level = c("national", "urban", "national"),
  pop = c(34e6, 12e6, 52e6)
)

p_pop <- fs::path(root, "inputs/population.qs")

# Save and record PK columns (uniqueness is enforced by default)
st_save(pop, p_pop, pk = c("country", "year", "reporting_level"))
```

What this does:

* Validates that PK columns exist (and are unique when `unique = TRUE`, the default).
* Persists `pk` into the **sidecar** (see below).
* Attaches `attr(x, "stamp_pk")` in memory for immediate reuse.

### Inspecting/adding PK later

```{r}
# Read PK from sidecar
st_inspect_pk(p_pop)

# If you saved earlier without PK, you can repair the sidecar:
st_add_pk(p_pop, keys = c("country", "year", "reporting_level"))
```

### Load-time behavior

```{r}
obj <- st_load(p_pop)
attr(obj, "stamp_pk") # keys attached on load for convenience
```

If a table is loaded **without** a recorded PK:

* If `st_opts(require_pk_on_load = TRUE)`: error.
* Else if `st_opts(warn_missing_pk_on_load = TRUE)`: warning.
* Else: silent.

Defaults (for now): `require_pk_on_load = FALSE`, `warn_missing_pk_on_load = TRUE`.

```{r}
# Example: enforce PK presence globally
st_opts(require_pk_on_load = TRUE)
# st_load("some_table_without_pk.qs")  # would error
st_opts(require_pk_on_load = FALSE) # restore default
```

### Convenience filter

For small, explicit slices you can filter by named values:

```{r}
per_nat <- st_filter(obj, list(country = "PER", reporting_level = "national"))
per_nat
```

## Sidecar metadata (quick reference)

Each artifact can have a **sidecar** stored under a sibling `stmeta/` directory. It records:

* `format`, `created_at`, `size_bytes`
* hashes: `content_hash`, `code_hash`, optional `file_hash`
* `parents` (provenance), `code_label`
* `pk` and optional `domain` (when saving data.frames with PK)

You can inspect it:

```{r}
side <- st_read_sidecar(p_pop)
names(side)
side$pk
```

When `st_opts(verify_on_load = TRUE)`, `st_load()` will warn on:

* Mismatch between `content_hash` and the hash of the loaded object.
* Mismatch between `file_hash` (if stored) and the on-disk file bytes.


## Partitioned datasets (Hive-style)

When you want one file **per key combo** without materializing a single huge table, you can use the partition helpers. Layout:

```
<base>/<k1>=<v1>/<k2>=<v2>/part.<ext>
```

### Save a partition

```{r}
base <- fs::path(root, "inputs/country_year")
st_save_part(
  x = data.frame(value = 1L),
  base = base,
  key = list(country = "PER", year = 2023),
  code = function(z) z
)
```

### List and load partitions

```{r}
st_list_parts(base)
st_list_parts(base, filter = list(country = "PER"))

# Row-bind all partitions (adds the key columns as regular columns)
all_parts <- st_load_parts(base, as = "rbind")
all_parts
```

> Under the hood, `st_save_part()` and friends reuse `st_save()`/`st_load()` and inherit all sidecar/PK behaviors.


## Notes & Recommendations

* **Latest is protected** regardless of policy.
* Use `dry_run = TRUE` before pruning a big catalog.
* Prefer recording **PKs at save time** (`st_save(..., pk = ...)`)—downstream code can safely assume identity.
* For reproducibility, consider logging a prune report with `dry_run = TRUE` to your project logs before destructive pruning on shared infrastructure.
