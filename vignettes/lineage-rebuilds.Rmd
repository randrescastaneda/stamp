---
title: "Lineage and Rebuilds"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Lineage and Rebuilds}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup}
# Use development build when interactive *and* explicitly enabled via env var.
dev_mode <- (Sys.getenv("DEV_VIGNETTES", "false") == "true")

if (dev_mode && requireNamespace("pkgload", quietly = TRUE)) {
  cli::cli_inform("loading with {.pkg pkgload}")
  pkgload::load_all()
} else {
  # fall back to the installed package (the path CRAN, CI, and pkgdown take)
  cli::cli_inform("loading with {.pkg library}")
  library(stamp)
}
```

This vignette shows how **stamp** captures **lineage** (parents → children), how to detect **staleness**, and how to **plan & rebuild** downstream artifacts in level order.

You’ll use:

- Lineage: `st_children()`, `st_lineage()`
- Staleness: `st_is_stale()`
- Planning: `st_plan_rebuild()` (returns a plan data.frame)
- Rebuilding: `st_register_builder()`, `st_clear_builders()`, `st_rebuild()`

> **Strict vs. Propagate**
> *Strict* checks actual mismatch vs the parents’ **current** latest versions.
> *Propagate* simulates change pushing downstream (A changes ⇒ schedule B ⇒ schedule C, etc.).

A few implementation notes that clarify behavior used by the examples below:

- Committed parents (the `parents.json` file inside a version snapshot) are the authoritative record for lineage when present. They are captured at commit time and are used for reproducible, recursive lineage walking.
- Sidecar parents (the `parents` field in the sidecar metadata written next to the artifact file) are a lightweight convenience that let you inspect first-level lineage before a snapshot is committed. `st_lineage()` falls back to sidecar parents only for the immediate parent level when no snapshot is available; recursive walking beyond level 1 requires snapshot-backed parents.

This design keeps interactive workflows fast (sidecars are quick) while preserving reproducible history once snapshots are written.

## Setup a tiny graph A → B(A) → C(B)

```{r}
st_opts_reset()
st_opts(
  versioning = "content",
  code_hash = TRUE,
  store_file_hash = TRUE,
  verify_on_load = TRUE,
  meta_format = "both"
)

root <- tempdir()
st_init(root)

# A
pA <- fs::path(root, "A.qs")
xA <- data.frame(a = 1:3)
st_save(xA, pA, code = function(z) z)

# B depends on A
pB <- fs::path(root, "B.qs")
xB <- transform(xA, b = a * 2)
st_save(
  xB,
  pB,
  code = function(z) z,
  parents = list(list(path = pA, version_id = st_latest(pA)))
)

# C depends on B
pC <- fs::path(root, "C.qs")
xC <- transform(xB, c = b + 1L)
st_save(
  xC,
  pC,
  code = function(z) z,
  parents = list(list(path = pB, version_id = st_latest(pB)))
)
```

Note: after these saves each artifact has a sidecar (in `stmeta/`) and snapshots under `.stamp/versions/`.

## Inspect lineage

```{r}
# Immediate children of A (depth 1)
st_children(pA, depth = 1)

# Full lineage (parents of an artifact)
st_lineage(pC, depth = Inf)
```

## Make a change upstream & detect staleness

```{r}
# Change A → new version
xA2 <- transform(xA, a = a + 10L)
st_save(xA2, pA, code = function(z) z)

# Strict staleness
st_is_stale(pB) # TRUE (B's recorded A version is now old)
st_is_stale(pC) # FALSE (C points to B, which hasn't changed yet)
```

## Plan rebuilds

Two strategies:

* **strict**: only items whose *recorded* parent IDs differ from parents’ *current latest*.
* **propagate**: assume targets will change and plan descendants in BFS layers.

```{r}
# Strict: only B right now
plan_strict <- st_plan_rebuild(pA, depth = Inf, mode = "strict")
plan_strict

# Propagate: includes B (level 1) and C (level 2)
plan <- st_plan_rebuild(pA, depth = Inf, mode = "propagate")
plan
```

## Register builders and rebuild in level order

Builders are tiny functions that **produce** an artifact from its parents.
They receive `(path, parents)` and return a list with at least `x = <object>`.

```{r}
# Clear any previous registry
st_clear_builders()

# Register a builder for B: rebuild from A's committed version
st_register_builder(pB, function(path, parents) {
  # parents is list(list(path=..., version_id=...))
  A <- st_load_version(parents[[1]]$path, parents[[1]]$version_id)
  list(
    x = transform(A, b = a * 2),
    code = function(z) z,
    code_label = "B <- A * 2"
  )
})

# Register a builder for C: rebuild from B's committed version
st_register_builder(pC, function(path, parents) {
  B <- st_load_version(parents[[1]]$path, parents[[1]]$version_id)
  list(
    x = transform(B, c = b + 1L),
    code = function(z) z,
    code_label = "C <- B + 1"
  )
})

# Dry run first (uses registered builders found by st_rebuild when rebuild_fun is NULL)
st_rebuild(plan, dry_run = TRUE)

# Now actually rebuild (will use registered builders)
res <- st_rebuild(plan, dry_run = FALSE)
res
```

After rebuilding B, **C** becomes strictly stale if **B** changes again later.
You can re-plan from B to keep propagating:

```{r}
st_is_stale(pB)
st_is_stale(pC)
st_plan_rebuild(pB, depth = Inf, mode = "propagate")
```

## Inspect snapshots on disk

```{r}
vroot <- stamp:::.st_versions_root()
fs::dir_tree(vroot, recurse = TRUE, all = TRUE)
```

**Tip:** `st_info(path)` summarizes sidecar, catalog status, and the latest snapshot dir, plus parsed `parents.json` from the committed snapshot (if present).

```{r}
st_info(pC)
```

### Takeaways

* Use **strict** staleness to detect objective mismatches.
* Use **propagate** planning to build a full downstream schedule.
* Keep builders small, pure, and deterministic; they make rebuilds trivial.

