---
title: "03. Lineage & Rebuilds"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Lineage & Rebuilds}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, message=FALSE}
# Use development build when interactive *and* explicitly enabled via env var.
dev_mode <- interactive() && (Sys.getenv("DEV_VIGNETTES", "false") == "true")

if (dev_mode && requireNamespace("pkgload", quietly = TRUE)) {
  pkgload::load_all(export_all = FALSE, helpers = FALSE, attach_testthat = FALSE)
} else {
  # fall back to the installed package (the path CRAN, CI, and pkgdown take)
  library(stamp)
}
```

This vignette shows how **stamp** captures **lineage** (parents → children), how to detect **staleness**, and how to **plan & rebuild** downstream artifacts in level order.

You’ll use:

* Lineage: `st_children()`, `st_lineage()`
* Staleness: `st_is_stale()`
* Planning: `st_plan_rebuild(targets, mode = "propagate" | "strict")`
* Rebuilding: `st_register_builder()`, `st_clear_builders()`, `st_rebuild()`

> **Strict vs. Propagate**
> *Strict* checks actual mismatch vs the parents’ **current** latest versions.
> *Propagate* simulates change pushing downstream (A changes ⇒ schedule B ⇒ schedule C, etc.).

## Setup a tiny graph A → B(A) → C(B)

```{r}
st_opts_reset()
st_opts(
  versioning      = "content",
  code_hash       = TRUE,
  store_file_hash = TRUE,
  verify_on_load  = TRUE,
  meta_format     = "both"
)

root <- tempdir()
st_init(root)

# A
pA <- fs::path(root, "A.qs")
xA <- data.frame(a = 1:3)
st_save(xA, pA, code = function(z) z)

# B depends on A
pB <- fs::path(root, "B.qs")
xB <- transform(xA, b = a * 2)
st_save(xB, pB,
        code    = function(z) z,
        parents = list(list(path = pA, version_id = st_latest(pA))))

# C depends on B
pC <- fs::path(root, "C.qs")
xC <- transform(xB, c = b + 1L)
st_save(xC, pC,
        code    = function(z) z,
        parents = list(list(path = pB, version_id = st_latest(pB))))
```

## Inspect lineage

```{r}
# Immediate children of A (depth 1)
st_children(pA, depth = 1)

# Full lineage (parents of an artifact)
st_lineage(pC, depth = Inf)
```

## Make a change upstream & detect staleness

```{r}
# Change A → new version
xA2 <- transform(xA, a = a + 10L)
st_save(xA2, pA, code = function(z) z)

# Strict staleness
st_is_stale(pB)         # TRUE (B's recorded A version is now old)
st_is_stale(pC)         # FALSE (C points to B, which hasn't changed yet)
```

## Plan rebuilds

Two strategies:

* **strict**: only items whose *recorded* parent IDs differ from parents’ *current latest*.
* **propagate**: assume targets will change and plan descendants in BFS layers.

```{r}
# Strict: only B right now
plan_strict <- st_plan_rebuild(pA, depth = Inf, mode = "strict")
plan_strict

# Propagate: includes B (level 1) and C (level 2)
plan <- st_plan_rebuild(pA, depth = Inf, mode = "propagate")
plan
```

## Register builders and rebuild in level order

Builders are tiny functions that **produce** an artifact from its parents.
They receive `(path, parents)` and return a list with at least `x = <object>`.

```{r}
# Clear any previous registry
st_clear_builders()

# Register a builder for B: rebuild from A's committed version
st_register_builder(pB, function(path, parents) {
  # parents is list(list(path=..., version_id=...))
  A <- st_load_version(parents[[1]]$path, parents[[1]]$version_id)
  list(
    x          = transform(A, b = a * 2),
    code       = function(z) z,
    code_label = "B <- A * 2"
  )
})

# Register a builder for C: rebuild from B's committed version
st_register_builder(pC, function(path, parents) {
  B <- st_load_version(parents[[1]]$path, parents[[1]]$version_id)
  list(
    x          = transform(B, c = b + 1L),
    code       = function(z) z,
    code_label = "C <- B + 1"
  )
})

# Dry run first
st_rebuild(plan, rebuild_fun = st_builder_for)

# Now actually rebuild
res <- st_rebuild(plan, rebuild_fun = st_builder_for, dry_run = FALSE)
res
```

After rebuilding B, **C** becomes strictly stale if **B** changes again later.
You can re-plan from B to keep propagating:

```{r}
st_is_stale(pB); st_is_stale(pC)
st_plan_rebuild(pB, depth = Inf, mode = "propagate")
```

## Inspect snapshots on disk

```{r}
vroot <- stamp:::.st_versions_root()
fs::dir_tree(vroot, recurse = TRUE, all = TRUE)
```

**Tip:** `st_info(path)` summarizes sidecar, catalog status, and the latest snapshot dir, plus parsed `parents.json` from the committed snapshot (if present).

```{r}
st_info(pC)
```

### Takeaways

* Use **strict** staleness to detect objective mismatches.
* Use **propagate** planning to build a full downstream schedule.
* Keep builders small, pure, and deterministic; they make rebuilds trivial.

