---
title: "Setup & Basics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Setup & Basics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup}
# If knitting outside the package, uncomment:
devtools::load_all()
# library(stamp)
```

Let’s initialize a project and configure global behavior for **stamp**. These knobs are meant to stay stable.

## Initialize a project

```{r}
# By default, st_init() uses the current working directory.
# For the vignette we’ll use a temp dir:
tdir <- tempdir()
st_init(tdir)  # creates .stamp/, .stamp/temp/, .stamp/logs/ under tdir

fs::path(tdir, ".stamp") |>
  fs::dir_tree(recurse = TRUE, all = TRUE)
```

* Default internal directory is `.stamp/`.
* You can change it: `st_init(state_dir = "_stamp")`.

## Options: `st_opts()`

`st_opts()` stores lightweight package options.

* `meta_format` controls how sidecar metadata is written/read:

  * `"json"` (default) — human-readable
  * `"qs2"` — compact, binary
  * `"both"` — write both; the reader prefers JSON when present

```{r}
# View current options
st_opts(.get = TRUE)

# Set sidecar format to JSON + QS2
st_opts(meta_format = "both")

# Read a single option
st_opts("meta_format", .get = TRUE)
```

## `st_path()`

Declare a path with an optional format hint. You can pass either a plain string
or an `st_path()` object to `st_save()` / `st_load()`.

```{r}
p1 <- st_path("data/iris.qs2")              # format inferred (qs2)
p2 <- st_path("data/mtcars.fst", format = "fst")
p1
```

## Format registry

Built-ins: `qs2` (default), `rds`, `csv`, `fst`, `json`.

```{r}
st_formats()
```

### Register or override a format

Keeps your project future-proof (e.g., add Parquet later).

```{r, eval=FALSE}
st_register_format(
  name = "parquet",
  read  = function(path, ...) arrow::read_parquet(path, ...),
  write = function(x, path, ...) arrow::write_parquet(x, path, ...)
)
st_formats()
```

Notes:

* `qs2` is preferred; if not installed, the registry transparently falls back to `{qs}`.
* CSV uses `{data.table}` for fast I/O if available.

## Saving & Loading Objects

Use `st_save()` and `st_load()` for atomic writes and reliable reads.

```{r}
x <- data.frame(a = 1:3, b = letters[1:3])
derdir <- fs::path_temp("derived")

st_save(
  x,
  fs::path(derdir, "example.qs2"),
  metadata = list(description = "toy")
)

# Load (format auto-detected)
y <- st_load(fs::path(derdir, "example.qs2"))
identical(x, y)
```

### Sidecar metadata

Each time you save a file with **stamp**, it creates a sidecar in a sibling directory `stmeta` next to the artifact:

* JSON: `stmeta/<file.ext>.stmeta.json`
* QS2:  `stmeta/<file.ext>.stmeta.qs2`
* Both if `st_opts(meta_format = "both")`

Contents include: `path`, `format`, `created_at` (UTC), `size_bytes`, `attrs` (reserved), plus any user `metadata`.

Read sidecars with `st_read_sidecar()`:

```{r}
st_read_sidecar(fs::path(derdir, "example.qs2"))

# Or inspect manually:
# jsonlite::read_json(fs::path(derdir, "stmeta/example.qs2.stmeta.json"), simplifyVector = TRUE)
# qs2::qs_read(fs::path(derdir, "stmeta/example.qs2.stmeta.qs2"))
```

### CSV & friends

```{r}
if (requireNamespace("data.table", quietly = TRUE)) {
  d <- data.table::data.table(id = 1:3, v = c(10, 20, 30))
  tabdir <- fs::path_temp("tables")
  tfile  <- fs::path(tabdir, "d.csv")

  st_save(d, tfile)        # uses data.table::fwrite()
  d2 <- st_load(tfile)     # uses data.table::fread()
  identical(as.data.frame(d), as.data.frame(d2))
}
```

## Project-level conventions

* Prefer **qs2** for artifacts (speed + compactness).
* Keep sidecars as **JSON** unless you prefer binary (set `st_opts(meta_format = "qs2")` or `"both"`).
* Use `st_path()` when you want code to be explicit about formats.
* Keep file layouts simple (e.g., `data/`, `derived/`, and `.stamp/`).
