---
title: "Setup & Basics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Setup & Basics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Let's initialize a project and configure global behavior for **stamp**. These knobs are meant to stay stable.

## Initialize a project

```{r}
devtools::load_all()
#library(stamp)

# By default, uses current working directory but we will use a temp dir here
tdir <- tempdir()
# Creates internal folders: .stamp/, .stamp/temp/, .stamp/logs/
st_init(tdir)               # st_init(root = ".", state_dir = ".stamp")
fs::path(tdir, ".stamp") |> 
  fs::dir_tree(recurse = TRUE, all = TRUE)
```

* Default internal directory is `.stamp/`.
* You can change it: `st_init(state_dir = "_stamp")`.

## Options: `st_opts()`

`st_opts()` stores lightweight package options. For example, the `meta_format` argument modifies how sidecar metadata is written/read.

  * `"json"` (default) — human-readable.
  * `"qs2"` — compact, binary.
  * `"both"` — write both; reader prefers JSON.

```{r}
# View current options
st_opts(.get = TRUE)

# Set sidecar format to JSON + QS2
st_opts(meta_format = "both")

# Read a single option
st_opts("meta_format", .get = TRUE)
```


## `st_path()`
Now, let's understand how **stamp** declares file paths and chooses formats.
Declare a path with an optional format hint (S3 object used by I/O helpers).

```{r}
p1 <- st_path("data/iris.qs2")                  # format inferred (qs2)
p2 <- st_path("data/mtcars.fst", format = "fst")
p1
```

You can pass either a plain string path or an `st_path()` to `st_save()` /
`st_load()`.

## Format registry

Built-ins: `qs2` (default), `rds`, `csv`, `fst`, `json`.

```{r}
st_formats()
```

### Register or override a format

Keeps your project future-proof (e.g., add Parquet later).

```{r}
st_register_format(
  name = "parquet",
  read = function(path, ...) arrow::read_parquet(path, ...),
  write = function(x, path, ...) arrow::write_parquet(x, path, ...)
)

st_formats()

```

* `qs2` is preferred; if not installed, the registry transparently falls back to `{qs}`.
* CSV uses `{data.table}` for fast I/O if available.


## Saving & Loading Objects
Use `st_save()` and `st_load()` for atomic writes and reliable reads.


```{r}

x <- data.frame(a = 1:3, b = letters[1:3])

# Save (atomic: temp -> move), sidecar written next to file
derdir <- fs::path_temp("derived")

st_save(x, 
        fs::path(derdir, "example.qs2"), 
        metadata = list(description = "toy"))

# Load (format auto-detected)
y <- st_load(fs::path(derdir, "example.qs2"))

identical(x, y)


fs::path(tdir) |> 
  fs::dir_tree(recurse = TRUE, all = TRUE)
```

### Sidecar metadata

each you save a file with **stamp**, it creates a metadata file in subdirectory "stmeta" next to your artifact:

* JSON: `file.ext.stmeta.json`
* QS2:  `file.ext.stmeta.qs2`
* Both if `st_opts(meta_format = "both")`

Contents:

* `path`, `format`, `created_at` (UTC), `size_bytes`, `attrs` (reserved), plus any user `metadata`.

You can read sidecars with `st_read_sidecar()`.
```{r} 
st_read_sidecar(fs::path(derdir, "example.qs2"))

# or inspect manually:
# jsonlite::read_json(fs::path(derdir, "stmeta/example.qs2.stmeta.json"), simplifyVector = TRUE)
# or qs2::qs_read("derived/example.qs2.stmeta.qs2")
```

### CSV & friends

```{r}
if (requireNamespace("data.table", quietly = TRUE)) {
  d <- data.table::data.table(id = 1:3, v = c(10, 20, 30))
  tabdir <- fs::path_temp("tables")
  tfile  <- fs::path(tabdir, "d.csv")
  
  st_save(d, tfile)        # uses data.table::fwrite
  d2 <- st_load(tfile)     # uses data.table::fread
  identical(d, d2)
  waldo::compare(d, d2)  # issues with doubles (need to check)
}
```


## Extending stamp (Formats & Conventions)
Extend **stamp** without changing its internals.

Use `st_register_format()` to add (or override) a format. Notice that this formats are register per session; you can wrap registrations in a script sourced at project startup. Otherwise, when you resetart R, you'll need to re-register them.

```{r}
# Example: Feather via {arrow}
if (requireNamespace("arrow", quietly = TRUE)) {
  st_register_format(
    "feather",
    read  = function(path, ...) arrow::read_feather(path, ...), # returns a tibble by default
    write = function(x, path, ...) arrow::write_feather(x, path, ...) 
  )

  tabdir <- fs::path_temp("tables")
  ffile  <- fs::path(tabdir, "iris.feather")

  st_save(iris, ffile, format = "feather")
  iris2 <- st_load(ffile)
  identical(iris, iris2)
  waldo::compare(iris, iris2) # they are different in class (data.frame vs tibble)
}
```

## Project-level conventions

* Prefer **qs2** for artifacts (speed + compactness).
* Keep sidecars as **JSON** unless you prefer binary (set `st_opts(meta_format = "qs2")` or `"both"`).
* Use `st_path()` when you want code to be explicit about formats.
* Keep file layouts simple (e.g., `data/`, `derived/`, and `.stamp/`).

