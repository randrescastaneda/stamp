% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/retention.R
\name{st_prune_versions}
\alias{st_prune_versions}
\title{Prune stored versions according to a retention policy}
\usage{
st_prune_versions(path = NULL, policy = Inf, dry_run = TRUE)
}
\arguments{
\item{path}{Optional character vector of artifact paths to restrict pruning.
If NULL (default), applies the policy to all artifacts in the catalog.}

\item{policy}{One of:
\itemize{
\item \code{Inf} (keep everything)
\item numeric scalar \code{n} (keep the \emph{n} most recent per artifact)
\item \verb{list(n = <int>, days = <num>)} (keep most recent \emph{n} and/or those
newer than \emph{days}; union of the two conditions)
}}

\item{dry_run}{logical; if TRUE, only report what would be pruned.}
}
\value{
Invisibly, a data.frame of pruned (or would-prune) versions with
columns: artifact_path, version_id, created_at, size_bytes.
}
\description{
Prune stored versions according to a retention policy
}
\details{
\strong{Retention policy semantics}
\itemize{
\item \code{policy = Inf} — keep \emph{all} versions (no pruning).
\item \verb{policy = <numeric>} — interpreted as “keep the \strong{n} most recent versions
per artifact.” For example, \code{policy = 2} keeps the latest two and prunes older ones.
\item \code{policy = list(...)} — a combined policy where multiple conditions are
UNIONed (kept if \strong{any} condition keeps it):
\itemize{
\item \code{n}: keep the latest \strong{n} per artifact.
\item \code{days}: keep versions whose \code{created_at} is within the last \strong{days} days.
\item \code{keep_latest} / \code{min_keep} (internal fields in some flows) ensure at least
a floor of versions are preserved; typical use is covered by \code{n} + \code{days}.
}
}

\strong{Grouping & order.} Pruning decisions are made per artifact, after sorting
each artifact’s versions by \code{created_at} (newest → oldest). The “latest n”
condition is applied on this order.

\strong{Dry runs vs destructive mode.} With \code{dry_run = TRUE}, the function only
reports what \emph{would} be pruned (and estimates reclaimed space). With
\code{dry_run = FALSE}, it deletes the snapshot directories under
\verb{<state_dir>/versions/...} and updates the catalog accordingly:
\itemize{
\item removes rows from the \code{versions} table,
\item adjusts each artifact’s \code{n_versions} and \code{latest_version_id}
(to the newest remaining version), or drops the artifact row if none remain.
}

\strong{Scope.} If supported in your build (e.g., you added a \code{path = NULL}
parameter), you can restrict pruning to a single artifact by passing its path.
Otherwise, pruning considers all artifacts recorded in the catalog.

\strong{Integration with writes.} If you set a default policy via
\verb{st_opts(retain_versions = <policy>)}, internal helpers may apply pruning
right after \code{st_save()} for the just-written artifact (keep-all is the default).

\strong{Safety notes.}
\itemize{
\item Pruning never touches the \strong{live artifact files} (\code{A.qs}, etc.) — only the
stored version snapshots and catalog entries.
\item Use \code{dry_run = TRUE} first to verify what would be removed.
}
}
\examples{
\donttest{
# Minimal setup: temp project with three artifacts and multiple versions
st_opts_reset()
st_opts(versioning = "content", meta_format = "json")

root <- tempdir()
st_init(root)

# A, B, C
pA <- fs::path(root, "A.qs"); xA <- data.frame(a = 1:3)
pB <- fs::path(root, "B.qs"); pC <- fs::path(root, "C.qs")

# First versions
st_save(xA, pA, code = function(z) z)
st_save(transform(xA, b = a * 2), pB, code = function(z) z,
        parents = list(list(path = pA, version_id = st_latest(pA))))
st_save(transform(st_load(pB), c = b + 1L), pC, code = function(z) z,
        parents = list(list(path = pB, version_id = st_latest(pB))))

# Create a couple of extra versions for A to have data to prune
st_save(transform(xA, a = a + 10L), pA, code = function(z) z)
st_save(transform(xA, a = a + 20L), pA, code = function(z) z)

# Inspect versions for A
st_versions(pA)

# 1) Keep everything (no-op)
st_prune_versions(policy = Inf, dry_run = TRUE)

# 2) Keep only the latest 1 per artifact (dry run)
st_prune_versions(policy = 1, dry_run = TRUE)

# 3) Combined policy:
#    - keep the latest 2 per artifact
#    - and also keep any versions newer than 7 days (union of both)
st_prune_versions(policy = list(n = 2, days = 7), dry_run = TRUE)

# 4) Restrict pruning to a single artifact path
st_prune_versions(path = pA, policy = 1, dry_run = TRUE)

# 5) Apply pruning (destructive): keep latest 1 everywhere
#    (Uncomment to run for real)
# st_prune_versions(policy = 1, dry_run = FALSE)

# Optional: set a default retention policy and have st_save() apply it
# after each write via .st_apply_retention() (internal helper).
# For example, keep last 2 versions going forward:
st_opts(retain_versions = 2)
# Next saves will write a new version and then prune older ones for that artifact.
}
}
