% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hashing.R
\name{st_hash_obj}
\alias{st_hash_obj}
\title{Stable SipHash-1-3 of an R object}
\usage{
st_hash_obj(x)
}
\arguments{
\item{x}{Any R object (data.frame, data.table, list, vector, etc.)}
}
\value{
Lowercase hex string (16 hex characters) from siphash13().
}
\description{
Computes a stable hash of an R object by serializing it with
\code{base::serialize(version = 3)} and hashing the resulting bytes via
\code{secretbase::siphash13()}. The hash is stable across R sessions (given the
same R version and object structure) and suitable for change detection.
}
\section{Attribute Normalization}{

Before hashing, this function normalizes the order of object attributes to
ensure consistent hashes even when operations (like \code{collapse::rowbind()} +
\code{collapse::funique()}) leave attributes in different orders.

The normalization reorders attributes to a canonical form:
\enumerate{
\item Priority attributes: names, row.names, class, .internal.selfref
\item Other attributes: alphabetically sorted
}

This ensures that logically identical objects produce identical hashes
regardless of their attribute creation history.
}

\section{Mutation Behavior (data.table only)}{

\strong{By default (\code{copydt = FALSE}), this function modifies data.table attributes in-place.}
The actual column data is never changed, but the order of attributes in the
object's metadata will be reordered to canonical form. This provides the best
performance for large data.tables (no memory overhead).

If you need to preserve the original attribute order, use \code{copydt = TRUE} to
create a shallow copy before normalization. This adds minimal overhead (the
copy only references the existing column data, it doesn't duplicate it).

\strong{For data.frames, lists, and other objects:} A new object is always returned
internally (normalization doesn't modify the input), regardless of \code{copydt}.
}

\section{Why This Matters}{

Without normalization, two data.frames that are \code{identical()} can produce
different hashes if their internal attributes are in different orders. This
breaks change detection in stamp, causing false positives where objects are
incorrectly flagged as changed.
}

\section{Performance}{

\itemize{
\item For small to medium objects: negligible overhead
\item For large objects: creates a shallow copy (data is referenced, not duplicated)
\item The normalization cost is typically < 1\% of total hashing time
}
}

\examples{
\dontrun{
# Two ways to create the "same" data
dt_a <- data.table(x = 1:5) |> funique()
dt_b <- data.table(x = 1:5) |> rowbind(data.table(x = 1:5)) |> funique()

# They're identical in content
identical(dt_a, dt_b)  # TRUE

# And now they hash the same too!
st_hash_obj(dt_a) == st_hash_obj(dt_b)  # TRUE
}

}
