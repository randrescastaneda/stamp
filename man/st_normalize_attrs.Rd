% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hashing.R
\name{st_normalize_attrs}
\alias{st_normalize_attrs}
\title{Normalize attributes for consistent hashing}
\usage{
st_normalize_attrs(x)
}
\arguments{
\item{x}{A data.frame, data.table, list, or other object.}
}
\value{
For data.tables: invisibly returns the modified object (mutated in-place).
For other objects: returns a new object with normalized attributes.
In both cases, the class is preserved.
}
\description{
Normalizes the order of object attributes to a canonical form. For data.tables,
modifies attributes in-place using \code{data.table::setattr()}. For other objects,
returns a new object with normalized attributes.
}
\section{Problem}{

Operations like \code{collapse::rowbind()} + \code{collapse::funique()} can leave
attributes in different orders even when content is identical. Since
\code{serialize()} includes attribute order, this causes different byte streams
and thus different hashes for logically identical objects.
}

\section{Solution}{

This function reorders attributes to a canonical order:
\enumerate{
\item Priority attributes: names, row.names, class, .internal.selfref
\item Additional attributes: alphabetically sorted
}
}

\section{Implementation Strategy}{

The function uses different approaches based on object type:

\strong{For data.table objects:}
\itemize{
\item Modifies attributes \strong{in-place} (mutates the input)
\item Uses \code{data.table::setattr()} exclusively for safe modification
\item \code{setattr()} ensures \code{.internal.selfref} and other internals stay consistent
\item No memory overhead (no copy created)
\item Returns invisibly for piping
}

\strong{For regular data.frames:}
\itemize{
\item Returns a new object with normalized attributes
\item Rebuilds from column list with canonical attribute order
\item Shallow copy (column data is referenced, not copied)
\item Preserves data.frame class
}

\strong{For lists and other objects:}
\itemize{
\item Returns a new object with normalized attributes
\item Uses \code{unclass()} + attribute replacement
}
}

\section{Performance}{

\itemize{
\item data.table path: Zero memory overhead (in-place modification)
\item data.frame/other paths: Shallow copy (column/element data referenced)
\item Fast path: returns unchanged if already in canonical order
\item Negligible overhead for most use cases (< 1\% of hashing time)
}
}

\keyword{internal}
